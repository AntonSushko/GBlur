#define _CRT_SECURE_NO_WARNINGS
#include <malloc.h>
#include <stdio.h> 
#include <stdint.h> 
#include <conio.h>
#include <math.h>
 
#pragma pack(push, 2) 
struct 
{ 
  uint16_t signature;
  uint32_t fileSize;
  uint16_t foo1;
  uint16_t foo2;
  uint32_t fileHeadSize;
  uint32_t headerSize; 
  uint32_t width;
  uint32_t height; 
  uint16_t colorDimensions;
  uint16_t density;
  uint32_t zipType;
  uint32_t massiveLength;
  uint32_t horResolution;
  uint32_t verResolution;
  uint32_t colorsQuantity;
  uint32_t shadesQuantity;
} fileStruck, fileStruck2; 
#pragma pack(pop) 
#define SQRT_2PI 2.506628274631
 
int main(int argc, char** argv) 
{ 
	char *InputName, *OutputName,*src, *dest;
		FILE *InputFile, *OutputFile;
		int offset;

	InputName = "in.bmp"; OutputName = "out.bmp";
	if (0 != fopen_s(&InputFile, InputName, "rb"))
	{
		printf("File not found\n");
		_getch();
		return 1;
	}
	fread_s(&fileStruck, sizeof(fileStruck), sizeof(fileStruck), 1, InputFile);
	fileStruck2 = fileStruck;
	if (fileStruck.signature != 19778 || fileStruck.density != 24)
    { 
		printf("Wrong file type\n"); 
		_getch(); 
		return 1; 
    } 
	src = (char*)malloc(fileStruck.massiveLength);
	dest = (char*)malloc(fileStruck.massiveLength);
    fread_s(src, fileStruck.massiveLength, fileStruck.massiveLength, 1, InputFile); 
    fclose(InputFile);
	
	if ((fileStruck.width * 3) % 4 == 0) { offset = 0; }
		else { offset = 4 - (fileStruck.width * 3) % 4; }
	
	Gblur(src, dest, fileStruck.width*3 + offset, fileStruck.height,2.0);
	
	fopen_s(&OutputFile, OutputName, "wb");
	fwrite(&fileStruck, sizeof(fileStruck), 1, OutputFile); 
    fwrite(dest, fileStruck.massiveLength, 1, OutputFile); 
    fclose(OutputFile);
	_getch();
    free(src); 

    return 0; 
} 

double Gauss(double sigma, double x)
{
	return exp(-(x * x) / (2.0 * sigma * sigma)) / (sigma * SQRT_2PI);
}

int win_size(double sigma)
{
	double SIGMA_FACTOR = 3; // пр-ло 3-х сигм
	return (1 + (((unsigned int)ceil(SIGMA_FACTOR * sigma)) * 2));
}

double* GKernel_1D(double **kernel, )
{
	
	int wincenter, x; // + 1 чтоб был центр ядра
	double *kern, sum = 0.0;

	wincenter = winsize / 2 ;
	kern = (double*)calloc(winsize, sizeof(double));

	for (x = 0; x < wincenter + 1; x++)
	{
		kern[wincenter - x] = kern[wincenter + x] = Gauss(sigma, x);
		sum += kern[wincenter - x] + ((x != 0) ? kern[wincenter + x] : 0.0);
	}
	for (x = 0; x < winsize; x++)        
		kern[x] /= sum;

	//*kernel = kern;
	return kern;
}

int Gblur(unsigned char* src, unsigned char* dst, int width, int height, double sigma)
{
	int	row, col, winsize, halfsize, k, offset;
	double Ixy;
	unsigned char I1;
	unsigned char *tmpimage = NULL;
	double *kernel; 

	winsize = GKernel_1D(&kernel, sigma); //  вычислил окно 1 раз для данного радиуса размытия

	if (!src || !dst) return -1;
	
	if ((tmpimage = (unsigned char*)calloc(width * height, sizeof(unsigned char))) == NULL)
		return -1;

	int count = 0;
	winsize *= 3;
	halfsize = winsize / 2;
	
	for (row = 0; row < height; row++)
		for (col = 0; col < width; col+=3)		
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k+=3) // мб по границам окна???
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width))  // херово с граничными пикселями(только половина окна юзается) 
			{
				I1 = *(src + row * width + col + k - halfsize); 
				//if (kernel[k]>0.1)
				Ixy += (unsigned int)(I1) * kernel[count];
				count++;
				// * or empty ?  
				//else Ixy += ((unsigned int)I1);
			}

		*(tmpimage + row * width + col) = (unsigned char)(ceil(Ixy)); // + 0,5 ??? 
		}
	
	
	for (row = 0; row < height; row++)
		for (col = 1; col < width ; col += 3)
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k += 3) 
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width))  
			{
			I1 = *(src + row * width + col + k - halfsize);
			Ixy += (unsigned int)(I1)* kernel[count];
			count++;
			}
		*(tmpimage + row * width + col) = (unsigned char)(ceil(Ixy)); // + 0,5 ??? 
		}
		
	for (row = 0; row < height; row++)
		for (col = 2; col < width; col += 3)
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k += 3) 
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width))  
			{
			I1 = *(src + row * width + col + k - halfsize);
			Ixy += (unsigned int)(I1)* kernel[count];
			count++;
			}

		*(tmpimage + row * width + col) = (unsigned char)(ceil(Ixy)); 
		}
		
	// вычисления по столбцам
	winsize /= 3;
	halfsize = winsize / 2;
	for (col = 0; col < width; col++)
		for (row = 0; row < height; row++)
		{
		Ixy = 0.0;
		for (k = 0; k < winsize; k++) 
			if ((k + row - halfsize >= 0) && (k + row - halfsize < height))
			{
			I1 = *(tmpimage + (row + k - halfsize) * width + col);
			Ixy += ((unsigned int)I1) * kernel[k];
			}
		*(dst + row * width + col) = (unsigned char)(ceil(Ixy)); 
		}
		
	free(tmpimage);
	free(kernel);

	return 0;
}






for (row = 0; row < height; row++)
		for (col = 0; col < width; col+=3)		
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k+=3) 
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width)) 
			{
				I1 = *(src + row * width + col + k - halfsize); 
				Ixy += (unsigned int)(I1) * kernel[count];
				count++;
			}

		*(tmp + row * width + col) = (unsigned char)(ceil(Ixy));
		}
	
		for (col = 1; col < width ; col += 3)
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k += 3) 
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width))  
			{
			I1 = *(src + row * width + col + k - halfsize);
			Ixy += (unsigned int)(I1)* kernel[count];
			count++;
			}
		*(tmp + row * width + col) = (unsigned char)(ceil(Ixy)); 
		}
		
		for (col = 2; col < width; col += 3)
		{
		Ixy = 0.0;
		count = 0;
		for (k = 1; k < winsize; k += 3) 
			if ((k + col - halfsize >= 0) && (k + col - halfsize < width))  
			{
			I1 = *(src + row * width + col + k - halfsize);
			Ixy += (unsigned int)(I1)* kernel[count];
			count++;
			}

		*(tmp + row * width + col) = (unsigned char)(ceil(Ixy)); 
		}