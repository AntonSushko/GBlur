; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Mustang\Desktop\”чеба\я—ѕ\Gaussian Blur\Lab2\Lab2\lab1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_fileStruck:BYTE:036H
COMM	_fileStruck2:BYTE:036H
_DATA	ENDS
PUBLIC	_Gauss
PUBLIC	_GKernel_1D
PUBLIC	_main
PUBLIC	_Gblur
PUBLIC	_win_size
PUBLIC	??_C@_06MOKNMIPF@in?4bmp?$AA@			; `string'
PUBLIC	??_C@_07DNBLKNLC@out?4bmp?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BA@MPGLGHGM@File?5not?5found?6?$AA@	; `string'
PUBLIC	??_C@_0BB@PNNNFJFF@Wrong?5file?5type?6?$AA@	; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40040d931ff62704
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fread_s:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp___getch:PROC
EXTRN	_exp:PROC
EXTRN	__imp__ceil:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@40040d931ff62704
CONST	SEGMENT
__real@40040d931ff62704 DQ 040040d931ff62704r	; 2.50663
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PNNNFJFF@Wrong?5file?5type?6?$AA@
CONST	SEGMENT
??_C@_0BB@PNNNFJFF@Wrong?5file?5type?6?$AA@ DB 'Wrong file type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPGLGHGM@File?5not?5found?6?$AA@
CONST	SEGMENT
??_C@_0BA@MPGLGHGM@File?5not?5found?6?$AA@ DB 'File not found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DNBLKNLC@out?4bmp?$AA@
CONST	SEGMENT
??_C@_07DNBLKNLC@out?4bmp?$AA@ DB 'out.bmp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MOKNMIPF@in?4bmp?$AA@
CONST	SEGMENT
??_C@_06MOKNMIPF@in?4bmp?$AA@ DB 'in.bmp', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\mustang\desktop\учеба\€сп\gaussian blur\lab2\lab2\lab1.c
;	COMDAT _win_size
_TEXT	SEGMENT
tv78 = -216						; size = 8
_SIGMA_FACTOR$ = -12					; size = 8
_sigma$ = 8						; size = 8
_win_size PROC						; COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 182  : 	double SIGMA_FACTOR = 3; // пр-ло 3-х сигм

  0001e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4008000000000000
  00026	f2 0f 11 45 f4	 movsd	 QWORD PTR _SIGMA_FACTOR$[ebp], xmm0

; 183  : 	return (1 + (((int)ceil(SIGMA_FACTOR * sigma)) * 2)); // + 1 чтоб был центр €дра

  0002b	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _SIGMA_FACTOR$[ebp]
  00030	f2 0f 59 45 08	 mulsd	 xmm0, QWORD PTR _sigma$[ebp]
  00035	8b f4		 mov	 esi, esp
  00037	83 ec 08	 sub	 esp, 8
  0003a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  00045	83 c4 08	 add	 esp, 8
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	dd 9d 28 ff ff
	ff		 fstp	 QWORD PTR tv78[ebp]
  00055	f2 0f 10 85 28
	ff ff ff	 movsd	 xmm0, QWORD PTR tv78[ebp]
  0005d	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00061	8d 44 00 01	 lea	 eax, DWORD PTR [eax+eax+1]

; 184  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_win_size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\mustang\desktop\учеба\€сп\gaussian blur\lab2\lab2\lab1.c
;	COMDAT _Gblur
_TEXT	SEGMENT
tv409 = -508						; size = 4
tv366 = -508						; size = 4
tv351 = -508						; size = 4
tv336 = -508						; size = 4
tv407 = -504						; size = 4
tv364 = -504						; size = 4
tv349 = -504						; size = 4
tv334 = -504						; size = 4
tv404 = -498						; size = 2
tv361 = -498						; size = 2
tv346 = -498						; size = 2
tv331 = -498						; size = 2
_kernel$ = -300						; size = 4
_tmp$ = -288						; size = 4
_c_all$ = -273						; size = 1
_r_g$ = -261						; size = 1
_r_b$ = -249						; size = 1
_r_r$ = -237						; size = 1
_col_all$ = -228					; size = 8
_row_r$ = -212						; size = 8
_row_b$ = -196						; size = 8
_row_g$ = -180						; size = 8
_count3$ = -164						; size = 4
_count2$ = -152						; size = 4
_count1$ = -140						; size = 4
_rows$ = -128						; size = 4
_count$ = -116						; size = 4
_k$ = -92						; size = 4
_halfsize$ = -80					; size = 4
_winsize$ = -68						; size = 4
_col_b$ = -56						; size = 4
_col_g$ = -44						; size = 4
_col_r$ = -32						; size = 4
_col$ = -20						; size = 4
_row$ = -8						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_sigma$ = 24						; size = 8
_Gblur	PROC						; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 01 00
	00		 sub	 esp, 508		; 000001fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-508]
  00012	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 76   : 	if (!src || !dest) return -1;

  0001e	83 7d 08 00	 cmp	 DWORD PTR _src$[ebp], 0
  00022	74 06		 je	 SHORT $LN24@Gblur
  00024	83 7d 0c 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00028	75 08		 jne	 SHORT $LN25@Gblur
$LN24@Gblur:
  0002a	83 c8 ff	 or	 eax, -1
  0002d	e9 7e 05 00 00	 jmp	 $LN26@Gblur
$LN25@Gblur:

; 77   : 
; 78   : 	int	row, col, col_r, col_g, col_b, winsize, halfsize, k, offset, count = 0, rows, count1, count2, count3;

  00032	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 79   : 	double  row_g, row_b, row_r, col_all;
; 80   : 	unsigned char  r_r, r_b, r_g, c_all;
; 81   : 	unsigned char *tmp = NULL;

  00039	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp$[ebp], 0

; 82   : 	double *kernel; 
; 83   : 
; 84   : 		winsize = win_size(sigma); 

  00043	83 ec 08	 sub	 esp, 8
  00046	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _sigma$[ebp]
  0004b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00050	e8 00 00 00 00	 call	 _win_size
  00055	83 c4 08	 add	 esp, 8
  00058	89 45 bc	 mov	 DWORD PTR _winsize$[ebp], eax

; 85   : 		kernel = GKernel_1D(winsize, sigma); //  вычислил окно 1 раз дл€ данного радиуса размыти€

  0005b	83 ec 08	 sub	 esp, 8
  0005e	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _sigma$[ebp]
  00063	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00068	8b 45 bc	 mov	 eax, DWORD PTR _winsize$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _GKernel_1D
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _kernel$[ebp], eax

; 86   : 		winsize *= 3; // размер окна в байтах

  0007a	6b 45 bc 03	 imul	 eax, DWORD PTR _winsize$[ebp], 3
  0007e	89 45 bc	 mov	 DWORD PTR _winsize$[ebp], eax

; 87   : 		halfsize = winsize / 2;

  00081	8b 45 bc	 mov	 eax, DWORD PTR _winsize$[ebp]
  00084	99		 cdq
  00085	2b c2		 sub	 eax, edx
  00087	d1 f8		 sar	 eax, 1
  00089	89 45 b0	 mov	 DWORD PTR _halfsize$[ebp], eax

; 88   : 
; 89   : 	if ((tmp = (char*)calloc(width * height, sizeof(char))) == NULL) // промежуточное изображение, размытое по строкам

  0008c	8b f4		 mov	 esi, esp
  0008e	6a 01		 push	 1
  00090	33 c9		 xor	 ecx, ecx
  00092	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00095	f7 65 14	 mul	 DWORD PTR _height$[ebp]
  00098	0f 90 c1	 seto	 cl
  0009b	f7 d9		 neg	 ecx
  0009d	0b c8		 or	 ecx, eax
  0009f	51		 push	 ecx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000a6	83 c4 08	 add	 esp, 8
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax
  000b6	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  000bd	75 08		 jne	 SHORT $LN23@Gblur

; 90   : 		return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	e9 e9 04 00 00	 jmp	 $LN26@Gblur
$LN23@Gblur:

; 91   : 	// вычислени€ по строкам
; 92   : 	for (row = 0; row < height; row++)

  000c7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$[ebp], 0
  000ce	eb 09		 jmp	 SHORT $LN22@Gblur
$LN21@Gblur:
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  000d3	83 c0 01	 add	 eax, 1
  000d6	89 45 f8	 mov	 DWORD PTR _row$[ebp], eax
$LN22@Gblur:
  000d9	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  000dc	3b 45 14	 cmp	 eax, DWORD PTR _height$[ebp]
  000df	0f 8d 49 03 00
	00		 jge	 $LN20@Gblur

; 93   : 	{ 
; 94   : 		col_r = 0;

  000e5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _col_r$[ebp], 0

; 95   : 		col_g = 1;

  000ec	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _col_g$[ebp], 1

; 96   : 		col_b = 2;

  000f3	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _col_b$[ebp], 2

; 97   : 		for (rows = 0; rows < width; rows+=3)

  000fa	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _rows$[ebp], 0
  00101	eb 09		 jmp	 SHORT $LN19@Gblur
$LN18@Gblur:
  00103	8b 45 80	 mov	 eax, DWORD PTR _rows$[ebp]
  00106	83 c0 03	 add	 eax, 3
  00109	89 45 80	 mov	 DWORD PTR _rows$[ebp], eax
$LN19@Gblur:
  0010c	8b 45 80	 mov	 eax, DWORD PTR _rows$[ebp]
  0010f	3b 45 10	 cmp	 eax, DWORD PTR _width$[ebp]
  00112	0f 8d 11 03 00
	00		 jge	 $LN17@Gblur

; 98   : 		{
; 99   : 			row_r = row_g = row_b = 0.0;

  00118	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@0000000000000000
  00120	f2 0f 11 85 3c
	ff ff ff	 movsd	 QWORD PTR _row_b$[ebp], xmm0
  00128	f2 0f 10 85 3c
	ff ff ff	 movsd	 xmm0, QWORD PTR _row_b$[ebp]
  00130	f2 0f 11 85 4c
	ff ff ff	 movsd	 QWORD PTR _row_g$[ebp], xmm0
  00138	f2 0f 10 85 4c
	ff ff ff	 movsd	 xmm0, QWORD PTR _row_g$[ebp]
  00140	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR _row_r$[ebp], xmm0

; 100  : 			count1 = count2 = count3 = 0;

  00148	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _count3$[ebp], 0
  00152	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _count3$[ebp]
  00158	89 85 68 ff ff
	ff		 mov	 DWORD PTR _count2$[ebp], eax
  0015e	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _count2$[ebp]
  00164	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _count1$[ebp], ecx

; 101  : 
; 102  : 			for (k = 1; k < winsize; k += 3)

  0016a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
  00171	eb 09		 jmp	 SHORT $LN16@Gblur
$LN15@Gblur:
  00173	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00176	83 c0 03	 add	 eax, 3
  00179	89 45 a4	 mov	 DWORD PTR _k$[ebp], eax
$LN16@Gblur:
  0017c	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  0017f	3b 45 bc	 cmp	 eax, DWORD PTR _winsize$[ebp]
  00182	0f 8d 52 01 00
	00		 jge	 $LN14@Gblur

; 103  : 			{
; 104  : 				if ((k + col_r - halfsize >= 0) && (k + col_r - halfsize < width))

  00188	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  0018b	03 45 e0	 add	 eax, DWORD PTR _col_r$[ebp]
  0018e	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  00191	78 64		 js	 SHORT $LN13@Gblur
  00193	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00196	03 45 e0	 add	 eax, DWORD PTR _col_r$[ebp]
  00199	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  0019c	3b 45 10	 cmp	 eax, DWORD PTR _width$[ebp]
  0019f	7d 56		 jge	 SHORT $LN13@Gblur

; 105  : 				{
; 106  : 					r_r = *(src + row * width + col_r + k - halfsize);

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  001a4	0f af 45 10	 imul	 eax, DWORD PTR _width$[ebp]
  001a8	03 45 08	 add	 eax, DWORD PTR _src$[ebp]
  001ab	03 45 e0	 add	 eax, DWORD PTR _col_r$[ebp]
  001ae	03 45 a4	 add	 eax, DWORD PTR _k$[ebp]
  001b1	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  001b4	8a 08		 mov	 cl, BYTE PTR [eax]
  001b6	88 8d 13 ff ff
	ff		 mov	 BYTE PTR _r_r$[ebp], cl

; 107  : 					row_r += (int)(r_r)* kernel[count1];

  001bc	0f b6 85 13 ff
	ff ff		 movzx	 eax, BYTE PTR _r_r$[ebp]
  001c3	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001c7	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _count1$[ebp]
  001cd	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _kernel$[ebp]
  001d3	f2 0f 59 04 ca	 mulsd	 xmm0, QWORD PTR [edx+ecx*8]
  001d8	f2 0f 58 85 2c
	ff ff ff	 addsd	 xmm0, QWORD PTR _row_r$[ebp]
  001e0	f2 0f 11 85 2c
	ff ff ff	 movsd	 QWORD PTR _row_r$[ebp], xmm0

; 108  : 					count1++;

  001e8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _count1$[ebp]
  001ee	83 c0 01	 add	 eax, 1
  001f1	89 85 74 ff ff
	ff		 mov	 DWORD PTR _count1$[ebp], eax
$LN13@Gblur:

; 109  : 				}
; 110  : 
; 111  : 				if ((k + col_g - halfsize >= 0) && (k + col_g - halfsize < width))

  001f7	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  001fa	03 45 d4	 add	 eax, DWORD PTR _col_g$[ebp]
  001fd	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  00200	78 64		 js	 SHORT $LN12@Gblur
  00202	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00205	03 45 d4	 add	 eax, DWORD PTR _col_g$[ebp]
  00208	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  0020b	3b 45 10	 cmp	 eax, DWORD PTR _width$[ebp]
  0020e	7d 56		 jge	 SHORT $LN12@Gblur

; 112  : 				{
; 113  : 					r_g = *(src + row * width + col_g + k - halfsize);

  00210	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  00213	0f af 45 10	 imul	 eax, DWORD PTR _width$[ebp]
  00217	03 45 08	 add	 eax, DWORD PTR _src$[ebp]
  0021a	03 45 d4	 add	 eax, DWORD PTR _col_g$[ebp]
  0021d	03 45 a4	 add	 eax, DWORD PTR _k$[ebp]
  00220	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  00223	8a 08		 mov	 cl, BYTE PTR [eax]
  00225	88 8d fb fe ff
	ff		 mov	 BYTE PTR _r_g$[ebp], cl

; 114  : 					row_g += (int)(r_g)* kernel[count2];

  0022b	0f b6 85 fb fe
	ff ff		 movzx	 eax, BYTE PTR _r_g$[ebp]
  00232	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00236	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _count2$[ebp]
  0023c	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _kernel$[ebp]
  00242	f2 0f 59 04 ca	 mulsd	 xmm0, QWORD PTR [edx+ecx*8]
  00247	f2 0f 58 85 4c
	ff ff ff	 addsd	 xmm0, QWORD PTR _row_g$[ebp]
  0024f	f2 0f 11 85 4c
	ff ff ff	 movsd	 QWORD PTR _row_g$[ebp], xmm0

; 115  : 					count2++;

  00257	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _count2$[ebp]
  0025d	83 c0 01	 add	 eax, 1
  00260	89 85 68 ff ff
	ff		 mov	 DWORD PTR _count2$[ebp], eax
$LN12@Gblur:

; 116  : 				}
; 117  : 
; 118  : 				if ((k + col_b - halfsize >= 0) && (k + col_b - halfsize < width))

  00266	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00269	03 45 c8	 add	 eax, DWORD PTR _col_b$[ebp]
  0026c	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  0026f	78 64		 js	 SHORT $LN11@Gblur
  00271	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00274	03 45 c8	 add	 eax, DWORD PTR _col_b$[ebp]
  00277	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  0027a	3b 45 10	 cmp	 eax, DWORD PTR _width$[ebp]
  0027d	7d 56		 jge	 SHORT $LN11@Gblur

; 119  : 				{
; 120  : 					r_b = *(src + row * width + col_b + k - halfsize);

  0027f	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  00282	0f af 45 10	 imul	 eax, DWORD PTR _width$[ebp]
  00286	03 45 08	 add	 eax, DWORD PTR _src$[ebp]
  00289	03 45 c8	 add	 eax, DWORD PTR _col_b$[ebp]
  0028c	03 45 a4	 add	 eax, DWORD PTR _k$[ebp]
  0028f	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  00292	8a 08		 mov	 cl, BYTE PTR [eax]
  00294	88 8d 07 ff ff
	ff		 mov	 BYTE PTR _r_b$[ebp], cl

; 121  : 					row_b += (int)(r_b)* kernel[count3];

  0029a	0f b6 85 07 ff
	ff ff		 movzx	 eax, BYTE PTR _r_b$[ebp]
  002a1	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  002a5	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _count3$[ebp]
  002ab	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _kernel$[ebp]
  002b1	f2 0f 59 04 ca	 mulsd	 xmm0, QWORD PTR [edx+ecx*8]
  002b6	f2 0f 58 85 3c
	ff ff ff	 addsd	 xmm0, QWORD PTR _row_b$[ebp]
  002be	f2 0f 11 85 3c
	ff ff ff	 movsd	 QWORD PTR _row_b$[ebp], xmm0

; 122  : 					count3++;

  002c6	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _count3$[ebp]
  002cc	83 c0 01	 add	 eax, 1
  002cf	89 85 5c ff ff
	ff		 mov	 DWORD PTR _count3$[ebp], eax
$LN11@Gblur:

; 123  : 				}
; 124  : 			}

  002d5	e9 99 fe ff ff	 jmp	 $LN15@Gblur
$LN14@Gblur:

; 125  : 
; 126  : 			*(tmp + row * width + col_r) = (unsigned char)(ceil(row_r));

  002da	8b f4		 mov	 esi, esp
  002dc	83 ec 08	 sub	 esp, 8
  002df	f2 0f 10 85 2c
	ff ff ff	 movsd	 xmm0, QWORD PTR _row_r$[ebp]
  002e7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  002f2	83 c4 08	 add	 esp, 8
  002f5	3b f4		 cmp	 esi, esp
  002f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fc	d9 bd 0e fe ff
	ff		 fnstcw	 WORD PTR tv331[ebp]
  00302	0f b7 85 0e fe
	ff ff		 movzx	 eax, WORD PTR tv331[ebp]
  00309	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0030e	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv334[ebp], eax
  00314	d9 ad 08 fe ff
	ff		 fldcw	 WORD PTR tv334[ebp]
  0031a	db 9d 04 fe ff
	ff		 fistp	 DWORD PTR tv336[ebp]
  00320	d9 ad 0e fe ff
	ff		 fldcw	 WORD PTR tv331[ebp]
  00326	8a 85 04 fe ff
	ff		 mov	 al, BYTE PTR tv336[ebp]
  0032c	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  0032f	0f af 4d 10	 imul	 ecx, DWORD PTR _width$[ebp]
  00333	03 8d e0 fe ff
	ff		 add	 ecx, DWORD PTR _tmp$[ebp]
  00339	8b 55 e0	 mov	 edx, DWORD PTR _col_r$[ebp]
  0033c	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 127  : 			*(tmp + row * width + col_g) = (unsigned char)(ceil(row_g));

  0033f	8b f4		 mov	 esi, esp
  00341	83 ec 08	 sub	 esp, 8
  00344	f2 0f 10 85 4c
	ff ff ff	 movsd	 xmm0, QWORD PTR _row_g$[ebp]
  0034c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  00357	83 c4 08	 add	 esp, 8
  0035a	3b f4		 cmp	 esi, esp
  0035c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00361	d9 bd 0e fe ff
	ff		 fnstcw	 WORD PTR tv346[ebp]
  00367	0f b7 85 0e fe
	ff ff		 movzx	 eax, WORD PTR tv346[ebp]
  0036e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00373	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv349[ebp], eax
  00379	d9 ad 08 fe ff
	ff		 fldcw	 WORD PTR tv349[ebp]
  0037f	db 9d 04 fe ff
	ff		 fistp	 DWORD PTR tv351[ebp]
  00385	d9 ad 0e fe ff
	ff		 fldcw	 WORD PTR tv346[ebp]
  0038b	8a 85 04 fe ff
	ff		 mov	 al, BYTE PTR tv351[ebp]
  00391	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  00394	0f af 4d 10	 imul	 ecx, DWORD PTR _width$[ebp]
  00398	03 8d e0 fe ff
	ff		 add	 ecx, DWORD PTR _tmp$[ebp]
  0039e	8b 55 d4	 mov	 edx, DWORD PTR _col_g$[ebp]
  003a1	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 128  : 			*(tmp + row * width + col_b) = (unsigned char)(ceil(row_b));

  003a4	8b f4		 mov	 esi, esp
  003a6	83 ec 08	 sub	 esp, 8
  003a9	f2 0f 10 85 3c
	ff ff ff	 movsd	 xmm0, QWORD PTR _row_b$[ebp]
  003b1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  003bc	83 c4 08	 add	 esp, 8
  003bf	3b f4		 cmp	 esi, esp
  003c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c6	d9 bd 0e fe ff
	ff		 fnstcw	 WORD PTR tv361[ebp]
  003cc	0f b7 85 0e fe
	ff ff		 movzx	 eax, WORD PTR tv361[ebp]
  003d3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003d8	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv364[ebp], eax
  003de	d9 ad 08 fe ff
	ff		 fldcw	 WORD PTR tv364[ebp]
  003e4	db 9d 04 fe ff
	ff		 fistp	 DWORD PTR tv366[ebp]
  003ea	d9 ad 0e fe ff
	ff		 fldcw	 WORD PTR tv361[ebp]
  003f0	8a 85 04 fe ff
	ff		 mov	 al, BYTE PTR tv366[ebp]
  003f6	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  003f9	0f af 4d 10	 imul	 ecx, DWORD PTR _width$[ebp]
  003fd	03 8d e0 fe ff
	ff		 add	 ecx, DWORD PTR _tmp$[ebp]
  00403	8b 55 c8	 mov	 edx, DWORD PTR _col_b$[ebp]
  00406	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 129  : 			col_r += 3;

  00409	8b 45 e0	 mov	 eax, DWORD PTR _col_r$[ebp]
  0040c	83 c0 03	 add	 eax, 3
  0040f	89 45 e0	 mov	 DWORD PTR _col_r$[ebp], eax

; 130  : 			col_g += 3;

  00412	8b 45 d4	 mov	 eax, DWORD PTR _col_g$[ebp]
  00415	83 c0 03	 add	 eax, 3
  00418	89 45 d4	 mov	 DWORD PTR _col_g$[ebp], eax

; 131  : 			col_b += 3; 

  0041b	8b 45 c8	 mov	 eax, DWORD PTR _col_b$[ebp]
  0041e	83 c0 03	 add	 eax, 3
  00421	89 45 c8	 mov	 DWORD PTR _col_b$[ebp], eax

; 132  : 		}

  00424	e9 da fc ff ff	 jmp	 $LN18@Gblur
$LN17@Gblur:

; 133  : 		}

  00429	e9 a2 fc ff ff	 jmp	 $LN21@Gblur
$LN20@Gblur:

; 134  : 
; 135  : 	// вычислени€ по столбцам
; 136  : 	winsize /= 3;

  0042e	8b 45 bc	 mov	 eax, DWORD PTR _winsize$[ebp]
  00431	99		 cdq
  00432	b9 03 00 00 00	 mov	 ecx, 3
  00437	f7 f9		 idiv	 ecx
  00439	89 45 bc	 mov	 DWORD PTR _winsize$[ebp], eax

; 137  : 	halfsize = winsize / 2;

  0043c	8b 45 bc	 mov	 eax, DWORD PTR _winsize$[ebp]
  0043f	99		 cdq
  00440	2b c2		 sub	 eax, edx
  00442	d1 f8		 sar	 eax, 1
  00444	89 45 b0	 mov	 DWORD PTR _halfsize$[ebp], eax

; 138  : 	for (col = 0; col < width; col++)

  00447	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  0044e	eb 09		 jmp	 SHORT $LN10@Gblur
$LN9@Gblur:
  00450	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  00453	83 c0 01	 add	 eax, 1
  00456	89 45 ec	 mov	 DWORD PTR _col$[ebp], eax
$LN10@Gblur:
  00459	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  0045c	3b 45 10	 cmp	 eax, DWORD PTR _width$[ebp]
  0045f	0f 8d 17 01 00
	00		 jge	 $LN8@Gblur

; 139  : 		for (row = 0; row < height; row++)

  00465	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$[ebp], 0
  0046c	eb 09		 jmp	 SHORT $LN7@Gblur
$LN6@Gblur:
  0046e	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  00471	83 c0 01	 add	 eax, 1
  00474	89 45 f8	 mov	 DWORD PTR _row$[ebp], eax
$LN7@Gblur:
  00477	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  0047a	3b 45 14	 cmp	 eax, DWORD PTR _height$[ebp]
  0047d	0f 8d f4 00 00
	00		 jge	 $LN5@Gblur

; 140  : 		{
; 141  : 		col_all = 0.0;

  00483	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@0000000000000000
  0048b	f2 0f 11 85 1c
	ff ff ff	 movsd	 QWORD PTR _col_all$[ebp], xmm0

; 142  : 		for (k = 0; k < winsize; k++) 

  00493	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0049a	eb 09		 jmp	 SHORT $LN4@Gblur
$LN3@Gblur:
  0049c	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  0049f	83 c0 01	 add	 eax, 1
  004a2	89 45 a4	 mov	 DWORD PTR _k$[ebp], eax
$LN4@Gblur:
  004a5	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  004a8	3b 45 bc	 cmp	 eax, DWORD PTR _winsize$[ebp]
  004ab	7d 63		 jge	 SHORT $LN2@Gblur

; 143  : 			if ((k + row - halfsize >= 0) && (k + row - halfsize < height))

  004ad	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  004b0	03 45 f8	 add	 eax, DWORD PTR _row$[ebp]
  004b3	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  004b6	78 56		 js	 SHORT $LN1@Gblur
  004b8	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  004bb	03 45 f8	 add	 eax, DWORD PTR _row$[ebp]
  004be	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  004c1	3b 45 14	 cmp	 eax, DWORD PTR _height$[ebp]
  004c4	7d 48		 jge	 SHORT $LN1@Gblur

; 144  : 			{
; 145  : 			c_all = *(tmp + (row + k - halfsize) * width + col);

  004c6	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  004c9	03 45 a4	 add	 eax, DWORD PTR _k$[ebp]
  004cc	2b 45 b0	 sub	 eax, DWORD PTR _halfsize$[ebp]
  004cf	0f af 45 10	 imul	 eax, DWORD PTR _width$[ebp]
  004d3	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _tmp$[ebp]
  004d9	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  004dc	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  004df	88 95 ef fe ff
	ff		 mov	 BYTE PTR _c_all$[ebp], dl

; 146  : 			col_all += ((int)c_all) * kernel[k];

  004e5	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _c_all$[ebp]
  004ec	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  004f0	8b 4d a4	 mov	 ecx, DWORD PTR _k$[ebp]
  004f3	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _kernel$[ebp]
  004f9	f2 0f 59 04 ca	 mulsd	 xmm0, QWORD PTR [edx+ecx*8]
  004fe	f2 0f 58 85 1c
	ff ff ff	 addsd	 xmm0, QWORD PTR _col_all$[ebp]
  00506	f2 0f 11 85 1c
	ff ff ff	 movsd	 QWORD PTR _col_all$[ebp], xmm0
$LN1@Gblur:

; 147  : 			}

  0050e	eb 8c		 jmp	 SHORT $LN3@Gblur
$LN2@Gblur:

; 148  : 		*(dest + row * width + col) = (unsigned char)(ceil(col_all));

  00510	8b f4		 mov	 esi, esp
  00512	83 ec 08	 sub	 esp, 8
  00515	f2 0f 10 85 1c
	ff ff ff	 movsd	 xmm0, QWORD PTR _col_all$[ebp]
  0051d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00522	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  00528	83 c4 08	 add	 esp, 8
  0052b	3b f4		 cmp	 esi, esp
  0052d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00532	d9 bd 0e fe ff
	ff		 fnstcw	 WORD PTR tv404[ebp]
  00538	0f b7 85 0e fe
	ff ff		 movzx	 eax, WORD PTR tv404[ebp]
  0053f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00544	89 85 08 fe ff
	ff		 mov	 DWORD PTR tv407[ebp], eax
  0054a	d9 ad 08 fe ff
	ff		 fldcw	 WORD PTR tv407[ebp]
  00550	db 9d 04 fe ff
	ff		 fistp	 DWORD PTR tv409[ebp]
  00556	d9 ad 0e fe ff
	ff		 fldcw	 WORD PTR tv404[ebp]
  0055c	8a 85 04 fe ff
	ff		 mov	 al, BYTE PTR tv409[ebp]
  00562	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  00565	0f af 4d 10	 imul	 ecx, DWORD PTR _width$[ebp]
  00569	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0056c	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  0056f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 149  : 		}

  00572	e9 f7 fe ff ff	 jmp	 $LN6@Gblur
$LN5@Gblur:
  00577	e9 d4 fe ff ff	 jmp	 $LN9@Gblur
$LN8@Gblur:

; 150  : 		
; 151  : 	free(tmp);

  0057c	8b f4		 mov	 esi, esp
  0057e	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00584	50		 push	 eax
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0058b	83 c4 04	 add	 esp, 4
  0058e	3b f4		 cmp	 esi, esp
  00590	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 152  : 	free(kernel);

  00595	8b f4		 mov	 esi, esp
  00597	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  0059d	50		 push	 eax
  0059e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  005a4	83 c4 04	 add	 esp, 4
  005a7	3b f4		 cmp	 esi, esp
  005a9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 153  : 
; 154  : 	return 0;

  005ae	33 c0		 xor	 eax, eax
$LN26@Gblur:

; 155  : }

  005b0	5f		 pop	 edi
  005b1	5e		 pop	 esi
  005b2	5b		 pop	 ebx
  005b3	81 c4 fc 01 00
	00		 add	 esp, 508		; 000001fcH
  005b9	3b ec		 cmp	 ebp, esp
  005bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005c0	8b e5		 mov	 esp, ebp
  005c2	5d		 pop	 ebp
  005c3	c3		 ret	 0
_Gblur	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\mustang\desktop\учеба\€сп\gaussian blur\lab2\lab2\lab1.c
;	COMDAT _main
_TEXT	SEGMENT
_offset$ = -84						; size = 4
_OutputFile$ = -72					; size = 4
_InputFile$ = -60					; size = 4
_dest$ = -48						; size = 4
_src$ = -36						; size = 4
_OutputName$ = -24					; size = 4
_InputName$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 35   : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 36   : 	char *InputName, *OutputName,*src, *dest;
; 37   : 		FILE *InputFile, *OutputFile;
; 38   : 		int offset;
; 39   : 
; 40   : 	InputName = "in.bmp"; OutputName = "out.bmp";

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _InputName$[ebp], OFFSET ??_C@_06MOKNMIPF@in?4bmp?$AA@
  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _OutputName$[ebp], OFFSET ??_C@_07DNBLKNLC@out?4bmp?$AA@

; 41   : 	if (0 != fopen_s(&InputFile, InputName, "rb"))

  00036	8b f4		 mov	 esi, esp
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0003d	8b 45 f4	 mov	 eax, DWORD PTR _InputName$[ebp]
  00040	50		 push	 eax
  00041	8d 4d c4	 lea	 ecx, DWORD PTR _InputFile$[ebp]
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	85 c0		 test	 eax, eax
  00057	74 30		 je	 SHORT $LN5@main

; 42   : 	{
; 43   : 		printf("File not found\n");

  00059	8b f4		 mov	 esi, esp
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MPGLGHGM@File?5not?5found?6?$AA@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00066	83 c4 04	 add	 esp, 4
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 44   : 		_getch();

  00070	8b f4		 mov	 esi, esp
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___getch
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 45   : 		return 1;

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	e9 eb 01 00 00	 jmp	 $LN6@main
$LN5@main:

; 46   : 	}
; 47   : 	fread_s(&fileStruck, sizeof(fileStruck), sizeof(fileStruck), 1, InputFile);

  00089	8b f4		 mov	 esi, esp
  0008b	8b 45 c4	 mov	 eax, DWORD PTR _InputFile$[ebp]
  0008e	50		 push	 eax
  0008f	6a 01		 push	 1
  00091	6a 36		 push	 54			; 00000036H
  00093	6a 36		 push	 54			; 00000036H
  00095	68 00 00 00 00	 push	 OFFSET _fileStruck
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread_s
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 48   : 	fileStruck2 = fileStruck;

  000aa	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  000af	be 00 00 00 00	 mov	 esi, OFFSET _fileStruck
  000b4	bf 00 00 00 00	 mov	 edi, OFFSET _fileStruck2
  000b9	f3 a5		 rep movsd
  000bb	66 a5		 movsw

; 49   : 	if (fileStruck.signature != 19778 || fileStruck.density != 24)

  000bd	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _fileStruck
  000c4	3d 42 4d 00 00	 cmp	 eax, 19778		; 00004d42H
  000c9	75 0c		 jne	 SHORT $LN3@main
  000cb	0f b7 05 1c 00
	00 00		 movzx	 eax, WORD PTR _fileStruck+28
  000d2	83 f8 18	 cmp	 eax, 24			; 00000018H
  000d5	74 30		 je	 SHORT $LN4@main
$LN3@main:

; 50   :     { 
; 51   : 		printf("Wrong file type\n"); 

  000d7	8b f4		 mov	 esi, esp
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PNNNFJFF@Wrong?5file?5type?6?$AA@
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000e4	83 c4 04	 add	 esp, 4
  000e7	3b f4		 cmp	 esi, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 52   : 		_getch(); 

  000ee	8b f4		 mov	 esi, esp
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___getch
  000f6	3b f4		 cmp	 esi, esp
  000f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 53   : 		return 1; 

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	e9 6d 01 00 00	 jmp	 $LN6@main
$LN4@main:

; 54   :     } 
; 55   : 	src = (char*)malloc(fileStruck.massiveLength);

  00107	8b f4		 mov	 esi, esp
  00109	a1 22 00 00 00	 mov	 eax, DWORD PTR _fileStruck+34
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	89 45 dc	 mov	 DWORD PTR _src$[ebp], eax

; 56   : 	dest = (char*)malloc(fileStruck.massiveLength);

  00122	8b f4		 mov	 esi, esp
  00124	a1 22 00 00 00	 mov	 eax, DWORD PTR _fileStruck+34
  00129	50		 push	 eax
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00130	83 c4 04	 add	 esp, 4
  00133	3b f4		 cmp	 esi, esp
  00135	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013a	89 45 d0	 mov	 DWORD PTR _dest$[ebp], eax

; 57   :     fread_s(src, fileStruck.massiveLength, fileStruck.massiveLength, 1, InputFile); 

  0013d	8b f4		 mov	 esi, esp
  0013f	8b 45 c4	 mov	 eax, DWORD PTR _InputFile$[ebp]
  00142	50		 push	 eax
  00143	6a 01		 push	 1
  00145	8b 0d 22 00 00
	00		 mov	 ecx, DWORD PTR _fileStruck+34
  0014b	51		 push	 ecx
  0014c	8b 15 22 00 00
	00		 mov	 edx, DWORD PTR _fileStruck+34
  00152	52		 push	 edx
  00153	8b 45 dc	 mov	 eax, DWORD PTR _src$[ebp]
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread_s
  0015d	83 c4 14	 add	 esp, 20			; 00000014H
  00160	3b f4		 cmp	 esi, esp
  00162	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 58   :     fclose(InputFile);

  00167	8b f4		 mov	 esi, esp
  00169	8b 45 c4	 mov	 eax, DWORD PTR _InputFile$[ebp]
  0016c	50		 push	 eax
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00173	83 c4 04	 add	 esp, 4
  00176	3b f4		 cmp	 esi, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 59   : 	
; 60   : 	if ((fileStruck.width * 3) % 4 == 0) { offset = 0; }

  0017d	6b 05 12 00 00
	00 03		 imul	 eax, DWORD PTR _fileStruck+18, 3
  00184	33 d2		 xor	 edx, edx
  00186	b9 04 00 00 00	 mov	 ecx, 4
  0018b	f7 f1		 div	 ecx
  0018d	85 d2		 test	 edx, edx
  0018f	75 09		 jne	 SHORT $LN2@main
  00191	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _offset$[ebp], 0
  00198	eb 1a		 jmp	 SHORT $LN1@main
$LN2@main:

; 61   : 		else { offset = 4 - (fileStruck.width * 3) % 4; }

  0019a	6b 05 12 00 00
	00 03		 imul	 eax, DWORD PTR _fileStruck+18, 3
  001a1	33 d2		 xor	 edx, edx
  001a3	b9 04 00 00 00	 mov	 ecx, 4
  001a8	f7 f1		 div	 ecx
  001aa	b8 04 00 00 00	 mov	 eax, 4
  001af	2b c2		 sub	 eax, edx
  001b1	89 45 ac	 mov	 DWORD PTR _offset$[ebp], eax
$LN1@main:

; 62   : 	
; 63   : 	Gblur(src, dest, fileStruck.width*3 + offset, fileStruck.height, 4.0); 

  001b4	83 ec 08	 sub	 esp, 8
  001b7	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4010000000000000
  001bf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001c4	a1 16 00 00 00	 mov	 eax, DWORD PTR _fileStruck+22
  001c9	50		 push	 eax
  001ca	6b 0d 12 00 00
	00 03		 imul	 ecx, DWORD PTR _fileStruck+18, 3
  001d1	03 4d ac	 add	 ecx, DWORD PTR _offset$[ebp]
  001d4	51		 push	 ecx
  001d5	8b 55 d0	 mov	 edx, DWORD PTR _dest$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 dc	 mov	 eax, DWORD PTR _src$[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _Gblur
  001e2	83 c4 18	 add	 esp, 24			; 00000018H

; 64   : 	
; 65   : 	fopen_s(&OutputFile, OutputName, "wb");

  001e5	8b f4		 mov	 esi, esp
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  001ec	8b 45 e8	 mov	 eax, DWORD PTR _OutputName$[ebp]
  001ef	50		 push	 eax
  001f0	8d 4d b8	 lea	 ecx, DWORD PTR _OutputFile$[ebp]
  001f3	51		 push	 ecx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fd	3b f4		 cmp	 esi, esp
  001ff	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   : 	fwrite(&fileStruck, sizeof(fileStruck), 1, OutputFile); 

  00204	8b f4		 mov	 esi, esp
  00206	8b 45 b8	 mov	 eax, DWORD PTR _OutputFile$[ebp]
  00209	50		 push	 eax
  0020a	6a 01		 push	 1
  0020c	6a 36		 push	 54			; 00000036H
  0020e	68 00 00 00 00	 push	 OFFSET _fileStruck
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00219	83 c4 10	 add	 esp, 16			; 00000010H
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 67   :     fwrite(dest, fileStruck.massiveLength, 1, OutputFile); 

  00223	8b f4		 mov	 esi, esp
  00225	8b 45 b8	 mov	 eax, DWORD PTR _OutputFile$[ebp]
  00228	50		 push	 eax
  00229	6a 01		 push	 1
  0022b	8b 0d 22 00 00
	00		 mov	 ecx, DWORD PTR _fileStruck+34
  00231	51		 push	 ecx
  00232	8b 55 d0	 mov	 edx, DWORD PTR _dest$[ebp]
  00235	52		 push	 edx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0023c	83 c4 10	 add	 esp, 16			; 00000010H
  0023f	3b f4		 cmp	 esi, esp
  00241	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :     fclose(OutputFile);

  00246	8b f4		 mov	 esi, esp
  00248	8b 45 b8	 mov	 eax, DWORD PTR _OutputFile$[ebp]
  0024b	50		 push	 eax
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00252	83 c4 04	 add	 esp, 4
  00255	3b f4		 cmp	 esi, esp
  00257	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :     free(src); 

  0025c	8b f4		 mov	 esi, esp
  0025e	8b 45 dc	 mov	 eax, DWORD PTR _src$[ebp]
  00261	50		 push	 eax
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00268	83 c4 04	 add	 esp, 4
  0026b	3b f4		 cmp	 esi, esp
  0026d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   : 
; 71   :     return 0; 

  00272	33 c0		 xor	 eax, eax
$LN6@main:

; 72   : } 

  00274	52		 push	 edx
  00275	8b cd		 mov	 ecx, ebp
  00277	50		 push	 eax
  00278	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@main
  0027e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00283	58		 pop	 eax
  00284	5a		 pop	 edx
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	5b		 pop	 ebx
  00288	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028b	33 cd		 xor	 ecx, ebp
  0028d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00292	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00298	3b ec		 cmp	 ebp, esp
  0029a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029f	8b e5		 mov	 esp, ebp
  002a1	5d		 pop	 ebp
  002a2	c3		 ret	 0
  002a3	90		 npad	 1
$LN11@main:
  002a4	02 00 00 00	 DD	 2
  002a8	00 00 00 00	 DD	 $LN10@main
$LN10@main:
  002ac	c4 ff ff ff	 DD	 -60			; ffffffc4H
  002b0	04 00 00 00	 DD	 4
  002b4	00 00 00 00	 DD	 $LN8@main
  002b8	b8 ff ff ff	 DD	 -72			; ffffffb8H
  002bc	04 00 00 00	 DD	 4
  002c0	00 00 00 00	 DD	 $LN9@main
$LN9@main:
  002c4	4f		 DB	 79			; 0000004fH
  002c5	75		 DB	 117			; 00000075H
  002c6	74		 DB	 116			; 00000074H
  002c7	70		 DB	 112			; 00000070H
  002c8	75		 DB	 117			; 00000075H
  002c9	74		 DB	 116			; 00000074H
  002ca	46		 DB	 70			; 00000046H
  002cb	69		 DB	 105			; 00000069H
  002cc	6c		 DB	 108			; 0000006cH
  002cd	65		 DB	 101			; 00000065H
  002ce	00		 DB	 0
$LN8@main:
  002cf	49		 DB	 73			; 00000049H
  002d0	6e		 DB	 110			; 0000006eH
  002d1	70		 DB	 112			; 00000070H
  002d2	75		 DB	 117			; 00000075H
  002d3	74		 DB	 116			; 00000074H
  002d4	46		 DB	 70			; 00000046H
  002d5	69		 DB	 105			; 00000069H
  002d6	6c		 DB	 108			; 0000006cH
  002d7	65		 DB	 101			; 00000065H
  002d8	00		 DB	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\mustang\desktop\учеба\€сп\gaussian blur\lab2\lab2\lab1.c
;	COMDAT _GKernel_1D
_TEXT	SEGMENT
tv88 = -252						; size = 8
tv77 = -252						; size = 8
_sum$ = -48						; size = 8
_kern$ = -32						; size = 4
_x$ = -20						; size = 4
_wincenter$ = -8					; size = 4
_win_size$ = 8						; size = 4
_sigma$ = 12						; size = 8
_GKernel_1D PROC					; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 159  : 	int wincenter, x;
; 160  : 	double *kern, sum = 0.0;

  0001e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@0000000000000000
  00026	f2 0f 11 45 d0	 movsd	 QWORD PTR _sum$[ebp], xmm0

; 161  : 	wincenter = win_size / 2;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _win_size$[ebp]
  0002e	99		 cdq
  0002f	2b c2		 sub	 eax, edx
  00031	d1 f8		 sar	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _wincenter$[ebp], eax

; 162  : 	kern = (double*)calloc(win_size, sizeof(double));

  00036	8b f4		 mov	 esi, esp
  00038	6a 08		 push	 8
  0003a	8b 45 08	 mov	 eax, DWORD PTR _win_size$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	89 45 e0	 mov	 DWORD PTR _kern$[ebp], eax

; 163  : 
; 164  : 	for (x = 0; x < wincenter + 1; x++)

  00051	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN6@GKernel_1D
$LN5@GKernel_1D:
  0005a	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax
$LN6@GKernel_1D:
  00063	8b 45 f8	 mov	 eax, DWORD PTR _wincenter$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	39 45 ec	 cmp	 DWORD PTR _x$[ebp], eax
  0006c	0f 8d a7 00 00
	00		 jge	 $LN4@GKernel_1D

; 165  : 	{
; 166  : 		kern[wincenter - x] = kern[wincenter + x] = Gauss(sigma, x);

  00072	f2 0f 2a 45 ec	 cvtsi2sd xmm0, DWORD PTR _x$[ebp]
  00077	83 ec 08	 sub	 esp, 8
  0007a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007f	83 ec 08	 sub	 esp, 8
  00082	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _sigma$[ebp]
  00087	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0008c	e8 00 00 00 00	 call	 _Gauss
  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	dd 9d 04 ff ff
	ff		 fstp	 QWORD PTR tv77[ebp]
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _wincenter$[ebp]
  0009d	03 45 ec	 add	 eax, DWORD PTR _x$[ebp]
  000a0	8b 4d e0	 mov	 ecx, DWORD PTR _kern$[ebp]
  000a3	f2 0f 10 85 04
	ff ff ff	 movsd	 xmm0, QWORD PTR tv77[ebp]
  000ab	f2 0f 11 04 c1	 movsd	 QWORD PTR [ecx+eax*8], xmm0
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _wincenter$[ebp]
  000b3	2b 55 ec	 sub	 edx, DWORD PTR _x$[ebp]
  000b6	8b 45 e0	 mov	 eax, DWORD PTR _kern$[ebp]
  000b9	f2 0f 10 85 04
	ff ff ff	 movsd	 xmm0, QWORD PTR tv77[ebp]
  000c1	f2 0f 11 04 d0	 movsd	 QWORD PTR [eax+edx*8], xmm0

; 167  : 		sum += kern[wincenter - x] + ((x != 0) ? kern[wincenter + x] : 0.0);

  000c6	83 7d ec 00	 cmp	 DWORD PTR _x$[ebp], 0
  000ca	74 18		 je	 SHORT $LN9@GKernel_1D
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _wincenter$[ebp]
  000cf	03 45 ec	 add	 eax, DWORD PTR _x$[ebp]
  000d2	8b 4d e0	 mov	 ecx, DWORD PTR _kern$[ebp]
  000d5	f2 0f 10 04 c1	 movsd	 xmm0, QWORD PTR [ecx+eax*8]
  000da	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv88[ebp], xmm0
  000e2	eb 10		 jmp	 SHORT $LN10@GKernel_1D
$LN9@GKernel_1D:
  000e4	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@0000000000000000
  000ec	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv88[ebp], xmm0
$LN10@GKernel_1D:
  000f4	8b 55 f8	 mov	 edx, DWORD PTR _wincenter$[ebp]
  000f7	2b 55 ec	 sub	 edx, DWORD PTR _x$[ebp]
  000fa	8b 45 e0	 mov	 eax, DWORD PTR _kern$[ebp]
  000fd	f2 0f 10 04 d0	 movsd	 xmm0, QWORD PTR [eax+edx*8]
  00102	f2 0f 58 85 04
	ff ff ff	 addsd	 xmm0, QWORD PTR tv88[ebp]
  0010a	f2 0f 58 45 d0	 addsd	 xmm0, QWORD PTR _sum$[ebp]
  0010f	f2 0f 11 45 d0	 movsd	 QWORD PTR _sum$[ebp], xmm0

; 168  : 	}

  00114	e9 41 ff ff ff	 jmp	 $LN5@GKernel_1D
$LN4@GKernel_1D:

; 169  : 	for (x = 0; x < win_size; x++)

  00119	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00120	eb 09		 jmp	 SHORT $LN3@GKernel_1D
$LN2@GKernel_1D:
  00122	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  00125	83 c0 01	 add	 eax, 1
  00128	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax
$LN3@GKernel_1D:
  0012b	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  0012e	3b 45 08	 cmp	 eax, DWORD PTR _win_size$[ebp]
  00131	7d 1d		 jge	 SHORT $LN1@GKernel_1D

; 170  : 		kern[x] /= sum;

  00133	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  00136	8b 4d e0	 mov	 ecx, DWORD PTR _kern$[ebp]
  00139	f2 0f 10 04 c1	 movsd	 xmm0, QWORD PTR [ecx+eax*8]
  0013e	f2 0f 5e 45 d0	 divsd	 xmm0, QWORD PTR _sum$[ebp]
  00143	8b 55 ec	 mov	 edx, DWORD PTR _x$[ebp]
  00146	8b 45 e0	 mov	 eax, DWORD PTR _kern$[ebp]
  00149	f2 0f 11 04 d0	 movsd	 QWORD PTR [eax+edx*8], xmm0
  0014e	eb d2		 jmp	 SHORT $LN2@GKernel_1D
$LN1@GKernel_1D:

; 171  : 
; 172  : 	return kern;

  00150	8b 45 e0	 mov	 eax, DWORD PTR _kern$[ebp]

; 173  : }

  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0015c	3b ec		 cmp	 ebp, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
_GKernel_1D ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\mustang\desktop\учеба\€сп\gaussian blur\lab2\lab2\lab1.c
;	COMDAT _Gauss
_TEXT	SEGMENT
tv86 = -208						; size = 8
tv83 = -200						; size = 8
_sigma$ = 8						; size = 8
_x$ = 16						; size = 8
_Gauss	PROC						; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 177  : 	return exp(-(x * x) / (2.0 * sigma * sigma)) / (sigma * SQRT_2PI);

  0001e	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _x$[ebp]
  00023	f2 0f 59 45 10	 mulsd	 xmm0, QWORD PTR _x$[ebp]
  00028	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00030	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00038	f2 0f 59 4d 08	 mulsd	 xmm1, QWORD PTR _sigma$[ebp]
  0003d	f2 0f 59 4d 08	 mulsd	 xmm1, QWORD PTR _sigma$[ebp]
  00042	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00046	83 ec 08	 sub	 esp, 8
  00049	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0004e	e8 00 00 00 00	 call	 _exp
  00053	83 c4 08	 add	 esp, 8
  00056	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv83[ebp]
  0005c	f2 0f 10 85 38
	ff ff ff	 movsd	 xmm0, QWORD PTR tv83[ebp]
  00064	f2 0f 10 4d 08	 movsd	 xmm1, QWORD PTR _sigma$[ebp]
  00069	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@40040d931ff62704
  00071	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00075	f2 0f 11 85 30
	ff ff ff	 movsd	 QWORD PTR tv86[ebp], xmm0
  0007d	dd 85 30 ff ff
	ff		 fld	 QWORD PTR tv86[ebp]

; 178  : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_Gauss	ENDP
_TEXT	ENDS
END
